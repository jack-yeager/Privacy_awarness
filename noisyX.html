<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Linear Regression with Differential Privacy</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.9.0/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@transpiled/python.js"></script>
</head>
<body>
    <h1>Multidimensional Linear Regression with Differential Privacy</h1>

    <label for="fileInput">Upload Dataset (CSV):</label>
    <input type="file" id="fileInput" accept=".csv">
    <br><br>

    <label for="noiseType">Select Noise Type:</label>
    <select id="noiseType" onchange="updatePlot()">
        <option value="Laplace">Laplace</option>
        <option value="Gaussian">Gaussian</option>
    </select>

    <label for="epsilon">Epsilon:</label>
    <input type="range" id="epsilon" min="0.01" max="20" step="0.01" value="1" onchange="updatePlot()">
    <span id="epsilonValue">1</span>
    <label for="resampleType">Resample:</label>
<select id="resampleType" onchange="resampleData()">
    <option value="none">None</option>
    <option value="downsample">Downsample</option>
    <option value="upsample">Upsample</option>
</select>

<script>
    function resampleData() {
        const resampleType = document.getElementById('resampleType').value;

        if (resampleType === 'none') {
            // No resampling, use the original data
            return;
        }

        if (resampleType === 'downsample') {
            // Example: Reduce the dataset to half its size
            const factor = 2;
            X = X.filter((_, index) => index % factor === 0);
            y = y.filter((_, index) => index % factor === 0);
        }

        if (resampleType === 'upsample') {
            // Example: Duplicate each data point (not ideal for all cases)
            const duplicatedX = [];
            const duplicatedY = [];
            X.forEach(row => {
                duplicatedX.push(row, row); // Duplicating rows
            });
            y.forEach(val => {
                duplicatedY.push(val, val); // Duplicating target
            });
            X = duplicatedX;
            y = duplicatedY;
        }

        // Update the plot after resampling
        updatePlot();
    }
</script>


    <canvas id="chart" width="800" height="600"></canvas>

    <script type="module">
        // Load Sklearn modules using Pyodide
        const pyodide = await loadPyodide();
        await pyodide.loadPackage('scikit-learn');

        let X = []; // Multidimensional input
        let y = []; // Output

        async function olsRegression(X, y) {
            const code = `
from sklearn.linear_model import LinearRegression
import numpy as np

def fit_model(X, y):
    model = LinearRegression()
    model.fit(X, y)
    return model.intercept_, model.coef_.tolist()

X = np.array(${JSON.stringify(X)})
y = np.array(${JSON.stringify(y)})
intercept, coefficients = fit_model(X, y)
(intercept, coefficients)
            `;
            const result = await pyodide.runPythonAsync(code);
            return result;
        }

        // Add Gaussian noise
        function addGaussianNoise(matrix, epsilon, delta = 1e-5, sensitivity = 1) {
            const sigma = Math.sqrt(2 * Math.log(1.25 / delta)) * sensitivity / epsilon;
            return matrix.map(row => row.map(value => value + (Math.random() - 0.5) * sigma));
        }

        // Add Laplace noise
        function addLaplaceNoise(matrix, epsilon, sensitivity = 1) {
            const scale = sensitivity / epsilon;
            return matrix.map(row => row.map(value => value + scale * (Math.log(1 - Math.random()) - Math.log(Math.random()))));
        }
        
        // Initialize Chart.js
        let chart = new Chart(document.getElementById('chart').getContext('2d'), {
            type: 'scatter',
            data: {
                datasets: [
                    {
                        label: 'Original Data (2D projection)',
                        data: [],
                        backgroundColor: 'red',
                        pointRadius: 3
                    },
                    {
                        label: 'Regression Line (Original)',
                        data: [],
                        type: 'line',
                        borderColor: 'yellow',
                        borderWidth: 2,
                        fill: false
                    },
                    {
                        label: 'Regression Line (With Noise)',
                        data: [],
                        type: 'line',
                        borderColor: 'blue',
                        borderWidth: 2,
                        fill: false
                    }
                ]
            },
            options: {
                scales: {
                    x: { type: 'linear', position: 'bottom', title: { display: true, text: 'X (Feature 1)' } },
                    y: { title: { display: true, text: 'y (Target)' } }
                },
                plugins: {
                    legend: { position: 'top' }
                }
            }
        });

        // Update the plot
        async function updatePlot() {
            if (X.length === 0 || y.length === 0) {
                alert("Please upload a dataset first.");
                return;
            }

            const noiseType = document.getElementById('noiseType').value;
            const epsilon = parseFloat(document.getElementById('epsilon').value);
            document.getElementById('epsilonValue').innerText = epsilon;

            let X_noisy;
            if (noiseType === 'Laplace') {
                X_noisy = addLaplaceNoise(X, epsilon);
            } else {
                X_noisy = addGaussianNoise(X, epsilon);
            }

            const [interceptOriginal, coefficientsOriginal] = await olsRegression(X, y);
            const [interceptNoisy, coefficientsNoisy] = await olsRegression(X_noisy, y);

            const X_projection = X.map(row => row[0]);
            const y_original = X_projection.map(x => interceptOriginal + coefficientsOriginal[0] * x);
            const y_noisy = X_projection.map(x => interceptNoisy + coefficientsNoisy[0] * x);

            chart.data.datasets[0].data = X.map((row, i) => ({ x: row[0], y: y[i] }));
            chart.data.datasets[1].data = X_projection.map((x, i) => ({ x, y: y_original[i] }));
            chart.data.datasets[2].data = X_projection.map((x, i) => ({ x, y: y_noisy[i] }));

            chart.update();
        }

        // Function to parse CSV and update data
        document.getElementById('fileInput').addEventListener('change', event => {
            const file = event.target.files[0];
            if (!file) {
                alert("Please upload a valid CSV file.");
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const content = e.target.result;
                const rows = content.split("\n").map(row => row.split(",").map(cell => cell.trim()));

                if (rows.length < 2) {
                    alert("CSV must have at least two rows (header + data).");
                    return;
                }

                const [header, ...dataRows] = rows;
                const yIndex = header.indexOf("y");
                const xIndices = header.map((_, i) => i).filter(i => i !== yIndex);

                if (yIndex === -1 || xIndices.length === 0) {
                    alert('CSV must have a column named "y" and at least one feature column.');
                    return;
                }

                X = dataRows.map(row => xIndices.map(index => parseFloat(row[index])))
                            .filter(row => row.every(value => !isNaN(value)));
                y = dataRows.map(row => parseFloat(row[yIndex]))
                            .filter(value => !isNaN(value));

                if (X.length === 0 || y.length === 0) {
                    alert("No valid numerical data found.");
                    return;
                }

                updatePlot();
            };

            reader.readAsText(file);
        });
    </script>
</body>
</html>
